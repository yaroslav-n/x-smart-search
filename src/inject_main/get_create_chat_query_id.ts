/**
 * X uses a technique called "persistent queries" to optimize the performance of its GraphQL API.
 * Instead of sending the full query string with each request, X frontend sends a query ID that corresponds to a specific query string.
 * This query ID is generated by the server and is unique to each query string.
 * This id can change at any time, but it doesn't mean the data we send needs to be changed necessarily.
 * For example, X team could add a new optional parameter to the query. This would change the query ID, but the data we send could remain the same.
 * 
 * We can get this ID from grok-related js files from X frontend. But they are loaded dynamically, and we can't guarantee they will be there when we inject our script.
 * Because of that, we'll download the grok-related scripts and search for the query ID there.
 * 
 * This is probably over-engineering and we could just hard-code query id, but fuck it, we ball
 */
export const getCreateChatQueryId = async (): Promise<string | null> => {
    const scriptsWithGrokCode = await getGrokScripts();

    // we could do a retry strategy here in the future
    const results = (await Promise.allSettled<Response>(scriptsWithGrokCode.map((url) => fetch(url))))
                        .filter((p) => p.status === 'fulfilled');
                                
    const grokSourceCodes: string[] = await Promise.all(results.map(async (r) => await (r as any).value.text())) // idk what is going on with typings here
    const createChatQueryId = findCreateChatQueryId(grokSourceCodes);

    return createChatQueryId;
}

/**
 * X has a list of on-demand js modules in the inline JS on the front page
 * @returns list of grok-related JS files
 */
const getGrokScripts =  (): string[] => {
    const linksEls = [...document.querySelectorAll("script")];
    const scriptWithScripts = linksEls.find((le) => le.innerText.indexOf('"i18n/en"') > -1)?.innerHTML;

    if (scriptWithScripts) {
        const onDemandScriptRegexp = /,"?([^"]+)"?:"([a-z0-9]{7})"/g;

        const foundIndex = scriptWithScripts.indexOf('"i18n/en"');
        const beforeStr = scriptWithScripts.substring(0, foundIndex);
        const startPos = beforeStr.lastIndexOf("{");
        const endPos = scriptWithScripts.indexOf("}", foundIndex) + 1;
        const scriptStr = scriptWithScripts.substring(startPos, endPos);

        // in X code, the files are written in object as key-value pairs, where key is the name of the file and value is the hash
        const grokScripts = [...scriptStr.matchAll(onDemandScriptRegexp)].map((regexpResult) => {
            const name = regexpResult[1];

            if (!name.toLowerCase().includes('grok')) {
                return null;
            }

            return `https://abs.twimg.com/responsive-web/client-web/${regexpResult[1]}.${regexpResult[2]}a.js`;
        }).filter((s) => s !== null) as string[];

        return grokScripts;
    } else {
        return []
    }
}

/**
 * This function gets source code of grok-related scripts and searches for the query ID
 * Outputs what it finds, or default query ID if nothing is found
 */
const findCreateChatQueryId = (grokSourceCodes: string[]): string | null => {
    const pattern = /queryId\s*:\s*"([a-zA-Z0-9]+)"\s*,\s*operationName\s*:\s*"CreateGrokConversation"/;

    for (const sourceCode of grokSourceCodes) {
        const queryIdMatch = sourceCode.match(pattern);

        if (queryIdMatch) {
            return queryIdMatch[1];
        }
    }

    return null;
}